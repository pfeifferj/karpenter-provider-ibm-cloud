name: Nightly Build

on:
  schedule:
    # Run at 2 AM UTC every day
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      tag_suffix:
        description: 'Tag suffix for the nightly build (e.g., alpha, beta)'
        required: false
        default: 'nightly'

env:
  REGISTRY: quay.io
  IMAGE_NAME: karpenter-provider-ibm-cloud/controller
  KO_DOCKER_REPO: quay.io/karpenter-provider-ibm-cloud/controller

jobs:
  generate-version:
    runs-on: ubuntu-latest
    outputs:
      nightly_version: ${{ steps.version.outputs.nightly_version }}
      short_sha: ${{ steps.version.outputs.short_sha }}
      commit_date: ${{ steps.version.outputs.commit_date }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate nightly version
        id: version
        run: |
          set -euo pipefail
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          SHORT_SHA=$(git rev-parse --short HEAD)
          COMMIT_DATE=$(git show -s --format=%cs)
          SUFFIX="${{ github.event.inputs.tag_suffix || 'nightly' }}"
          NIGHTLY_VERSION="${LATEST_TAG}-${COMMIT_DATE}-${SHORT_SHA}-${SUFFIX}"

          echo "nightly_version=$NIGHTLY_VERSION" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "commit_date=$COMMIT_DATE" >> $GITHUB_OUTPUT
          echo "Generated nightly version: $NIGHTLY_VERSION"

  build-amd64-arm64:
    runs-on: ubuntu-latest
    needs: generate-version
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: true

      - name: Install ko
        uses: ko-build/setup-ko@v0.6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to quay.io
        uses: docker/login-action@v3
        with:
          registry: quay.io
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_PASSWORD }}

      - name: Build and push amd64
        env:
          GOFLAGS: "-ldflags=-X=main.version=${{ needs.generate-version.outputs.nightly_version }}"
        run: |
          set -euo pipefail
          ko build --platform=linux/amd64 --bare \
            --tags=${{ needs.generate-version.outputs.nightly_version }}-amd64 \
            ./cmd/controller

      - name: Build and push arm64
        env:
          GOFLAGS: "-ldflags=-X=main.version=${{ needs.generate-version.outputs.nightly_version }}"
        run: |
          set -euo pipefail
          ko build --platform=linux/arm64 --bare \
            --tags=${{ needs.generate-version.outputs.nightly_version }}-arm64 \
            ./cmd/controller

  build-s390x:
    runs-on: [self-hosted, ibm-s390x]
    needs: generate-version
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Log in to quay.io
        uses: docker/login-action@v3
        with:
          registry: quay.io
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_PASSWORD }}

      - name: Build s390x binary
        run: |
          set -euo pipefail
          CGO_ENABLED=0 GOOS=linux GOARCH=s390x go build \
            -ldflags="-X=main.version=${{ needs.generate-version.outputs.nightly_version }}" \
            -o controller ./cmd/controller

          if [ ! -f controller ]; then
            echo "Error: Binary not created"
            exit 1
          fi

      - name: Build and push s390x image
        run: |
          set -euo pipefail
          VERSION="${{ needs.generate-version.outputs.nightly_version }}"
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}-s390x"

          cat > Dockerfile.s390x << 'EOF'
          FROM gcr.io/distroless/static:nonroot
          COPY controller /controller
          ENTRYPOINT ["/controller"]
          EOF

          docker build -f Dockerfile.s390x -t "${IMAGE}" .
          docker push "${IMAGE}"

          # Verify push succeeded
          docker buildx imagetools inspect "${IMAGE}" > /dev/null
          echo "Successfully pushed ${IMAGE}"

      - name: Cleanup
        if: always()
        run: |
          rm -f Dockerfile.s390x controller
          docker system prune -f --filter "until=1h" || true

  create-manifest:
    runs-on: ubuntu-latest
    needs: [generate-version, build-amd64-arm64, build-s390x]
    timeout-minutes: 10
    permissions:
      contents: read
      packages: write

    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to quay.io
        uses: docker/login-action@v3
        with:
          registry: quay.io
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_PASSWORD }}

      - name: Verify all architecture images exist
        run: |
          set -euo pipefail
          VERSION="${{ needs.generate-version.outputs.nightly_version }}"

          for ARCH in amd64 arm64 s390x; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}-${ARCH}"
            echo "Checking ${IMAGE}..."
            if ! docker buildx imagetools inspect "${IMAGE}" > /dev/null 2>&1; then
              echo "Error: Image for ${ARCH} not found: ${IMAGE}"
              exit 1
            fi
          done
          echo "All architecture images verified"

      - name: Create and push multi-arch manifest
        run: |
          set -euo pipefail
          VERSION="${{ needs.generate-version.outputs.nightly_version }}"
          MANIFEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          # Create versioned manifest
          docker buildx imagetools create -t "${MANIFEST}:${VERSION}" \
            "${MANIFEST}:${VERSION}-amd64" \
            "${MANIFEST}:${VERSION}-arm64" \
            "${MANIFEST}:${VERSION}-s390x"

          # Create 'nightly' tag pointing to latest nightly
          docker buildx imagetools create -t "${MANIFEST}:nightly" \
            "${MANIFEST}:${VERSION}-amd64" \
            "${MANIFEST}:${VERSION}-arm64" \
            "${MANIFEST}:${VERSION}-s390x"

      - name: Validate manifest contains all architectures
        run: |
          set -euo pipefail
          VERSION="${{ needs.generate-version.outputs.nightly_version }}"
          MANIFEST="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}"

          echo "Inspecting manifest..."
          docker buildx imagetools inspect "${MANIFEST}"

          MANIFEST_JSON=$(docker buildx imagetools inspect --raw "${MANIFEST}")
          for ARCH in amd64 arm64 s390x; do
            if ! echo "${MANIFEST_JSON}" | grep -q "\"architecture\":\"${ARCH}\""; then
              echo "Error: Architecture ${ARCH} not found in manifest"
              exit 1
            fi
          done
          echo "Manifest validated: all architectures present"

      - name: Create build summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # Nightly Build Summary

          ## Version Information
          - **Nightly Version**: \`${{ needs.generate-version.outputs.nightly_version }}\`
          - **Commit SHA**: \`${{ needs.generate-version.outputs.short_sha }}\`
          - **Commit Date**: \`${{ needs.generate-version.outputs.commit_date }}\`

          ## Images Published
          - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.generate-version.outputs.nightly_version }}\`
          - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:nightly\`

          ## Platforms
          - linux/amd64
          - linux/arm64
          - linux/s390x

          ## Usage
          \`\`\`bash
          podman pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:nightly
          \`\`\`
          EOF

  notify-failure:
    runs-on: ubuntu-latest
    needs: [generate-version, build-amd64-arm64, build-s390x, create-manifest]
    if: ${{ always() && contains(needs.*.result, 'failure') }}
    steps:
      - name: Create issue for failed nightly build
        uses: actions/github-script@v7
        with:
          script: |
            const date = new Date().toISOString().split('T')[0];
            const title = `Nightly build failed - ${date}`;

            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: ['nightly-build-failure'],
              state: 'open'
            });

            const existingIssue = issues.data.find(issue => issue.title === title);

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: `The nightly build failed on ${date}.\n\nWorkflow run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
                labels: ['nightly-build-failure', 'automated']
              });
            }
