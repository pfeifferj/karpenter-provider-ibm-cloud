name: Cleanup Old Nightly Builds

on:
  schedule:
    # Run weekly on Sundays at 3 AM UTC
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      retention_days:
        description: 'Number of days to retain nightly builds'
        required: false
        default: '7'
      dry_run:
        description: 'Dry run (show what would be deleted without deleting)'
        required: false
        type: boolean
        default: false

jobs:
  cleanup:
    runs-on: ubuntu-latest

    steps:
      - name: Cleanup old nightly builds
        uses: actions/github-script@v7
        env:
          QUAY_API_TOKEN: ${{ secrets.QUAY_API_TOKEN }}
        with:
          script: |
            const retentionDays = parseInt('${{ github.event.inputs.retention_days || 7 }}');
            const dryRun = ${{ github.event.inputs.dry_run || false }};
            const quayRepo = 'karpenter-provider-ibm-cloud/controller';
            const quayApi = 'https://quay.io/api/v1';
            const quayToken = process.env.QUAY_API_TOKEN;

            console.log(`Retention period: ${retentionDays} days`);
            console.log(`Dry run: ${dryRun}`);

            if (!quayToken) {
              console.log('Error: QUAY_API_TOKEN secret must be configured (OAuth Access Token from Quay.io)');
              return;
            }

            // Use Bearer auth with OAuth token (required for API delete operations)
            const authHeader = `Bearer ${quayToken}`;

            // Fetch all tags with pagination
            let allTags = [];
            let page = 1;
            let hasMore = true;

            while (hasMore) {
              const response = await fetch(
                `${quayApi}/repository/${quayRepo}/tag/?limit=100&page=${page}`,
                { headers: { 'Authorization': authHeader } }
              );

              if (!response.ok) {
                console.log(`Error fetching tags: ${response.status} ${response.statusText}`);
                return;
              }

              const data = await response.json();
              if (data.tags && data.tags.length > 0) {
                allTags = allTags.concat(data.tags);
                page++;
                hasMore = data.has_additional;
              } else {
                hasMore = false;
              }
            }

            const now = new Date();
            const cutoffDate = new Date(now.getTime() - (retentionDays * 24 * 60 * 60 * 1000));

            console.log(`Cutoff date: ${cutoffDate.toISOString()}`);
            console.log(`Total tags found: ${allTags.length}`);

            // Filter nightly tags
            const nightlyTags = allTags.filter(t => {
              return t.name.startsWith('nightly-') ||
                t.name.match(/^v\d+\.\d+\.\d+-\d{4}-\d{2}-\d{2}-[a-f0-9]+-/);
            });

            console.log(`Nightly tags found: ${nightlyTags.length}`);

            // Filter old tags
            const tagsToDelete = nightlyTags.filter(t => {
              const lastModified = new Date(t.last_modified);
              return lastModified < cutoffDate;
            });

            console.log(`Tags to delete: ${tagsToDelete.length}`);

            if (tagsToDelete.length === 0) {
              console.log('No old nightly builds to clean up');
              return;
            }

            // Create summary
            let summary = '# Nightly Build Cleanup Summary\n\n';
            summary += `- **Retention Period**: ${retentionDays} days\n`;
            summary += `- **Cutoff Date**: ${cutoffDate.toISOString()}\n`;
            summary += `- **Total Nightly Tags**: ${nightlyTags.length}\n`;
            summary += `- **Tags to Delete**: ${tagsToDelete.length}\n`;
            summary += `- **Dry Run**: ${dryRun}\n\n`;

            summary += '## Tags to be deleted:\n\n';
            summary += '| Tag | Last Modified |\n';
            summary += '|-----|---------------|\n';

            for (const tag of tagsToDelete) {
              summary += `| ${tag.name} | ${tag.last_modified} |\n`;

              if (!dryRun) {
                try {
                  const deleteResponse = await fetch(
                    `${quayApi}/repository/${quayRepo}/tag/${tag.name}`,
                    {
                      method: 'DELETE',
                      headers: { 'Authorization': authHeader }
                    }
                  );

                  if (deleteResponse.ok || deleteResponse.status === 204) {
                    console.log(`Deleted tag: ${tag.name}`);
                  } else {
                    const errorBody = await deleteResponse.text();
                    console.warn(`Failed to delete ${tag.name}: ${deleteResponse.status} - ${errorBody}`);
                  }
                } catch (error) {
                  console.error(`Failed to delete tag ${tag.name}: ${error.message}`);
                }
              }
            }

            // Write summary
            const fs = require('fs');
            fs.writeFileSync(process.env.GITHUB_STEP_SUMMARY, summary);

            if (dryRun) {
              console.log('Dry run completed - no tags were actually deleted');
            } else {
              console.log('Cleanup completed');
            }
